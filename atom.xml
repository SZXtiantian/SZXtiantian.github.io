<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小天天的茶舍</title>
  
  <subtitle>大家好， 我是小天天</subtitle>
  <link href="https://szxtiantian.github.io/atom.xml" rel="self"/>
  
  <link href="https://szxtiantian.github.io/"/>
  <updated>2022-10-27T15:45:07.933Z</updated>
  <id>https://szxtiantian.github.io/</id>
  
  <author>
    <name>TimTim</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java集合类学习心得</title>
    <link href="https://szxtiantian.github.io/2022/10/27/Java%E9%9B%86%E5%90%88%E7%B1%BB%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    <id>https://szxtiantian.github.io/2022/10/27/Java%E9%9B%86%E5%90%88%E7%B1%BB%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</id>
    <published>2022-10-27T09:37:17.000Z</published>
    <updated>2022-10-27T15:45:07.933Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java集合类学习心得"><a href="#Java集合类学习心得" class="headerlink" title="Java集合类学习心得"></a><strong><strong>Java集合类学习心得</strong></strong></h1><h2 id="1-单列集合框架结构"><a href="#1-单列集合框架结构" class="headerlink" title="1.单列集合框架结构"></a><strong>1.单列集合框架结构</strong></h2><blockquote><p>|—-Collection接口：单列集合，用来存储一个一个的对象<br>|———List接口：存储序的、可重复的数据。–&gt;“动态”数组<br>|—————ArrayList、LinkedList(csp20170302)、Vector<br>|———Set接口：存储无序的、不可重复的数据  –&gt;高中讲的“集合”<br>|—————HashSet(LeetCode 217)、LinkedHashSet、TreeSet</p></blockquote><h2 id="2-List接口"><a href="#2-List接口" class="headerlink" title="2.List接口"></a><strong>2.List接口</strong></h2><h3 id="2-1常用方法"><a href="#2-1常用方法" class="headerlink" title="2.1常用方法"></a>2.1常用方法</h3><blockquote><ul><li>增：add(Object obj)  </li><li>删：remove(int index) &#x2F; remove(Object obj)</li><li>改：set(int index, Object ele)</li><li>查：get(int index)</li><li>插：add(int index, Object ele)</li><li>长度：size()</li></ul></blockquote><h3 id="2-2常用实现类"><a href="#2-2常用实现类" class="headerlink" title="2.2常用实现类"></a>2.2常用实现类</h3><blockquote><p>|—–Collection接口：单列集合，用来存储一个一个的对象<br>|———-List接口：存储序的、可重复的数据。  –&gt;“动态”数组,替换原的数组<br>|————–ArrayList：查找，直接当数组用；底层用Object[] elementData存<br>|————–LinkedList：频繁增删，LinkedList效率比ArrayList高；底层用双向链表存<br>|————–Vector：ArrayList似乎能代替它。</p></blockquote><h3 id="2-3使用-LinkedList为例"><a href="#2-3使用-LinkedList为例" class="headerlink" title="2.3使用(LinkedList为例)"></a>2.3使用(LinkedList为例)</h3><h4 id="题目-csp20170302《学生排队》"><a href="#题目-csp20170302《学生排队》" class="headerlink" title="题目:csp20170302《学生排队》"></a>题目:csp20170302《学生排队》</h4><p><strong>问题描述</strong></p><blockquote><p>体育老师小明要将自己班上的学生按顺序排队。他首先让学生按学号从小到大的顺序排成一排，学号小的排在前面，然后进行多次调整。一次调整小明可能让一位同学出队，向前或者向后移动一段距离后再插入队列。<br>例如，下面给出了一组移动的例子，例子中学生的人数为8人。  </p><ul><li>0）初始队列中学生的学号依次为1, 2, 3, 4, 5, 6, 7, 8；</li><li>1）第一次调整，命令为“3号同学向后移动2”，表示3号同学出队，向后移动2名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 5, 3, 6, 7, 8；  </li><li>2）第二次调整，命令为“8号同学向前移动3”，表示8号同学出队，向前移动3名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 5, 8, 3, 6, 7；  </li><li>3）第三次调整，命令为“3号同学向前移动2”，表示3号同学出队，向前移动2名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 3, 5, 8, 6, 7。</li></ul><p>小明记录了所有调整的过程，请问，最终从前向后所有学生的学号依次是多少？<br>请特别注意，上述移动过程中所涉及的号码指的是学号，而不是在队伍中的位置。<br>在向后移动时，移动的距离不超过对应同学后面的人数，如果向后移动的距离正好等于对应同学后面的人数则该同学会移动到队列的最后面。<br>在向前移动时，移动的距离不超过对应同学前面的人数，如果向前移动的距离正好等于对应同学前面的人数则该同学会移动到队列的最前面。  </p></blockquote><p><strong>输入格式</strong></p><blockquote><p>输入的第一行包含一个整数n，表示学生的数量，学生的学号由1到n编号。<br>第二行包含一个整数m，表示调整的次数。<br>接下来m行，每行两个整数p, q，如果q为正，表示学号为p的同学向后移动q，如果q为负，表示学号为p的同学向前移动-q。  </p></blockquote><p><strong>输出格式</strong></p><blockquote><p>输出一行，包含n个整数，相邻两个整数之间由一个空格分隔，表示最终从前向后所有学生的学号。</p></blockquote><p><strong>样例输入</strong></p><blockquote><p>8<br>2<br>8 -3<br>3 -2</p></blockquote><p><strong>样例输出</strong>  </p><blockquote><p>1 2 4 3 5 8 6 7</p></blockquote><p><strong>解题思路</strong></p><blockquote><p>1.需要对学生位置进行多次调整，（多次增删）所以选择LinkedList这一数据结构<br>2.注意样例输出是一行！！！<br><img src="/pic1/jkol.png" alt="解题思路流程图"><br>注：不超越边界的情况下，后移时q要加1才能到达对应位置。<br>原因是后移到temp+q位置的后面插入，而不是在temp+q位置插，而前移直接加q即可到达对应位置。</p></blockquote><p><strong>Java代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @Description</span><br><span class="line"> * @author TimTim Email:754595995@qq.com</span><br><span class="line"> * @version</span><br><span class="line"> * @date 2022年10月19日下午1:59:16</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Main &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Scanner scanner = new Scanner(System.in);</span><br><span class="line">LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;();</span><br><span class="line">int n = scanner.nextInt();</span><br><span class="line">int m = scanner.nextInt();</span><br><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">list.addLast(i);</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">int p = scanner.nextInt();</span><br><span class="line">int q = scanner.nextInt();</span><br><span class="line">int temp = list.indexOf(p);</span><br><span class="line">if (q &gt; 0) &#123;</span><br><span class="line">if (temp + q + 1 &gt; list.size() - 1) &#123;</span><br><span class="line">list.addLast(p);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">list.add(temp + q + 1, p);</span><br><span class="line">&#125;</span><br><span class="line">list.remove(temp);</span><br><span class="line">&#125; else if (q &lt; 0) &#123;</span><br><span class="line">if (temp + q &lt; 0) &#123;</span><br><span class="line">list.addFirst(p);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">list.add(temp + q, p);</span><br><span class="line">&#125;</span><br><span class="line">list.remove(temp + 1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">System.out.print(list.get(i) + &quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">scanner.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Set接口"><a href="#3-Set接口" class="headerlink" title="3.Set接口"></a><strong>3.Set接口</strong></h2><h3 id="3-1常用方法"><a href="#3-1常用方法" class="headerlink" title="3.1常用方法"></a>3.1常用方法</h3><blockquote><p>没额外定义新方法，都是Collection中声明过的方法。</p></blockquote><h3 id="3-2常用实现类"><a href="#3-2常用实现类" class="headerlink" title="3.2常用实现类"></a>3.2常用实现类</h3><blockquote><p>|—-Collection接口：单列集合，用来存储一个一个的对象<br>|————HashSet：线程不安全的；可以存储null值<br>|——————LinkedHashSet：HashSet的子类；遍历其内部数据时，可以按照添&gt;加的顺序遍历;频繁遍历，LinkedHashSet效率高于HashSet.<br>|————TreeSet：可以照添加对象的指定属性，进行排序。</p></blockquote><h3 id="3-3使用-以hashSet为例"><a href="#3-3使用-以hashSet为例" class="headerlink" title="3.3使用(以hashSet为例)"></a>3.3使用(以hashSet为例)</h3><h4 id="题目LeetCode-217《存在重复元素》"><a href="#题目LeetCode-217《存在重复元素》" class="headerlink" title="题目LeetCode 217《存在重复元素》"></a><strong>题目LeetCode 217《存在重复元素》</strong></h4><p><strong>问题描述</strong></p><blockquote><p>给你一个整数数组nums。如果任一值在数组中出现至少两次。返回true；<br>如果数组中每个元素互不相同，返回false。<br>示例 1:<br>输入: [1,2,3,1]<br>输出: true<br>示例 2:<br>输入: [1,2,3,4]<br>输出: false<br>示例 3:<br>输入: [1,1,1,3,3,4,3,2,4,2]<br>输出: true  </p></blockquote><p><strong>解题思路</strong></p><blockquote><ol><li>利用HashSet的特点：存储不可重复的数据，实现去重操作；  </li><li>HashSet中的元素个数等于nums中的元素个数，即没有重复数据，return false; 否则return true。</li></ol></blockquote><p><strong>Java代码</strong>   </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean containsDuplicate(int[] nums) &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        for(int num : nums) &#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        if(nums.length == set.size())&#123;</span><br><span class="line">         return false;</span><br><span class="line">        &#125;</span><br><span class="line">           </span><br><span class="line">        else&#123;</span><br><span class="line">        return true;</span><br><span class="line">        &#125;          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>continue…</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java集合类学习心得&quot;&gt;&lt;a href=&quot;#Java集合类学习心得&quot; class=&quot;headerlink&quot; title=&quot;Java集合类学习心得&quot;&gt;&lt;/a&gt;&lt;strong&gt;&lt;strong&gt;Java集合类学习心得&lt;/strong&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;h2</summary>
      
    
    
    
    <category term="Programming" scheme="https://szxtiantian.github.io/categories/Programming/"/>
    
    
    <category term="Java" scheme="https://szxtiantian.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://szxtiantian.github.io/2022/10/26/hello-world/"/>
    <id>https://szxtiantian.github.io/2022/10/26/hello-world/</id>
    <published>2022-10-26T15:55:13.191Z</published>
    <updated>2022-10-26T17:38:11.645Z</updated>
    
    
    
    
    
  </entry>
  
</feed>
